//  alpaca package
//
//  Author: S.Hamblett <steve.hamblett@linux.com>
//  Copyright Â© 2023 S. Hamblett
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// ignore_for_file: camel_case_types, non_constant_identifier_names, constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Holds ffigen generated implementation bindings to the Alpaca utils library.
class UtilsImpl {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  UtilsImpl(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  UtilsImpl.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int gpt_params_parse(
    int argc,
    ffi.Pointer<ffi.Pointer<ffi.Char>> argv,
    gpt_params arg2,
  ) {
    return _gpt_params_parse(
      argc,
      argv,
      arg2,
    );
  }

  late final _gpt_params_parsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Pointer<ffi.Char>>,
              gpt_params)>>('gpt_params_parse');
  late final _gpt_params_parse = _gpt_params_parsePtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Pointer<ffi.Char>>, gpt_params)>();

  void gpt_print_usage(
    int argc,
    ffi.Pointer<ffi.Pointer<ffi.Char>> argv,
    gpt_params arg2,
  ) {
    return _gpt_print_usage(
      argc,
      argv,
      arg2,
    );
  }

  late final _gpt_print_usagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Pointer<ffi.Char>>,
              gpt_params)>>('gpt_print_usage');
  late final _gpt_print_usage = _gpt_print_usagePtr.asFunction<
      void Function(int, ffi.Pointer<ffi.Pointer<ffi.Char>>, gpt_params)>();

  late final ffi.Pointer<ffi.Int> _std = _lookup<ffi.Int>('std');

  int get std => _std.value;

  set std(int value) => _std.value = value;

  void replace(
    int std,
  ) {
    return _replace(
      std,
    );
  }

  late final _replacePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('replace');
  late final _replace = _replacePtr.asFunction<void Function(int)>();

  int gpt_vocab_init(
    int std,
  ) {
    return _gpt_vocab_init(
      std,
    );
  }

  late final _gpt_vocab_initPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('gpt_vocab_init');
  late final _gpt_vocab_init =
      _gpt_vocab_initPtr.asFunction<int Function(int)>();

  late final ffi.Pointer<ffi.Int> _gpt_vocab1 = _lookup<ffi.Int>('gpt_vocab');

  int get gpt_vocab1 => _gpt_vocab1.value;

  set gpt_vocab1(int value) => _gpt_vocab1.value = value;

  void sample_top_k(
    int std,
  ) {
    return _sample_top_k(
      std,
    );
  }

  late final _sample_top_kPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('sample_top_k');
  late final _sample_top_k = _sample_top_kPtr.asFunction<void Function(int)>();

  int ggml_quantize_q4_0(
    ffi.Pointer<ffi.Float> src,
    ffi.Pointer<ffi.Void> dst,
    int n,
    int k,
    int qk,
    ffi.Pointer<ffi.Int> hist,
  ) {
    return _ggml_quantize_q4_0(
      src,
      dst,
      n,
      k,
      qk,
      hist,
    );
  }

  late final _ggml_quantize_q4_0Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Int>)>>('ggml_quantize_q4_0');
  late final _ggml_quantize_q4_0 = _ggml_quantize_q4_0Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Void>, int, int, int,
          ffi.Pointer<ffi.Int>)>();

  int ggml_quantize_q4_1(
    ffi.Pointer<ffi.Float> src,
    ffi.Pointer<ffi.Void> dst,
    int n,
    int k,
    int qk,
    ffi.Pointer<ffi.Int> hist,
  ) {
    return _ggml_quantize_q4_1(
      src,
      dst,
      n,
      k,
      qk,
      hist,
    );
  }

  late final _ggml_quantize_q4_1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Int>)>>('ggml_quantize_q4_1');
  late final _ggml_quantize_q4_1 = _ggml_quantize_q4_1Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Void>, int, int, int,
          ffi.Pointer<ffi.Int>)>();
}

class gpt_params extends ffi.Struct {
  @ffi.Int()
  external int seed;

  @ffi.Int()
  external int n_threads;

  @ffi.Int()
  external int n_predict;

  @ffi.Int()
  external int repeat_last_n;

  @ffi.Int()
  external int n_ctx;

  @ffi.Int()
  external int top_k;

  @ffi.Float()
  external double top_p;

  @ffi.Float()
  external double temp;

  @ffi.Float()
  external double repeat_penalty;

  @ffi.Int()
  external int n_batch;

  @ffi.Int()
  external int std;

  @ffi.Int()
  external int use_color;

  @ffi.Int()
  external int interactive;

  @ffi.Int()
  external int interactive_start;
}

class gpt_vocab extends ffi.Struct {
  @ffi.Int()
  external int id;

  @ffi.Int()
  external int token;

  @ffi.Int()
  external int std;
}
